drop extension if exists "pg_net";


  create table "public"."User" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."User" enable row level security;


  create table "public"."goals" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null default auth.uid(),
    "text" text not null,
    "done" boolean not null default false,
    "inserted_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."goals" enable row level security;


  create table "public"."profiles" (
    "id" uuid not null,
    "name" text,
    "birth_date" date,
    "phone" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."profiles" enable row level security;


  create table "public"."schedules" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null default auth.uid(),
    "title" text not null,
    "descr" text,
    "date" date not null,
    "favorite" boolean not null default false,
    "alarm_time" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."schedules" enable row level security;


  create table "public"."user_settings" (
    "user_id" uuid not null,
    "app_lock" boolean not null default false,
    "daily_reminder" boolean not null default true,
    "weekly_report" boolean not null default false,
    "exam_alert" boolean not null default true,
    "data_opt_in" boolean not null default false,
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."user_settings" enable row level security;

CREATE UNIQUE INDEX "User_pkey" ON public."User" USING btree (id);

CREATE UNIQUE INDEX goals_pkey ON public.goals USING btree (id);

CREATE INDEX idx_goals_done ON public.goals USING btree (user_id, done);

CREATE INDEX idx_goals_user ON public.goals USING btree (user_id);

CREATE INDEX idx_schedules_date ON public.schedules USING btree (user_id, date);

CREATE INDEX idx_schedules_user ON public.schedules USING btree (user_id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX schedules_pkey ON public.schedules USING btree (id);

CREATE UNIQUE INDEX user_settings_pkey ON public.user_settings USING btree (user_id);

alter table "public"."User" add constraint "User_pkey" PRIMARY KEY using index "User_pkey";

alter table "public"."goals" add constraint "goals_pkey" PRIMARY KEY using index "goals_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."schedules" add constraint "schedules_pkey" PRIMARY KEY using index "schedules_pkey";

alter table "public"."user_settings" add constraint "user_settings_pkey" PRIMARY KEY using index "user_settings_pkey";

alter table "public"."goals" add constraint "goals_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."goals" validate constraint "goals_user_id_fkey";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."schedules" add constraint "schedules_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."schedules" validate constraint "schedules_user_id_fkey";

alter table "public"."user_settings" add constraint "user_settings_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) ON DELETE CASCADE not valid;

alter table "public"."user_settings" validate constraint "user_settings_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  INSERT INTO public.profiles (id, name, birth_date, phone)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data->>'name',
    NULLIF(NEW.raw_user_meta_data->>'birth','')::DATE,
    NEW.raw_user_meta_data->>'phone'
  )
  ON CONFLICT (id) DO NOTHING;
  RETURN NEW;
END; $function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user_settings()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  INSERT INTO public.user_settings (user_id)
  VALUES (NEW.id)
  ON CONFLICT (user_id) DO NOTHING;
  RETURN NEW;
END; $function$
;

CREATE OR REPLACE FUNCTION public.prevent_user_id_change()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF NEW.user_id IS DISTINCT FROM OLD.user_id THEN
    RAISE EXCEPTION 'user_id is immutable';
  END IF;
  RETURN NEW;
END; $function$
;

CREATE OR REPLACE FUNCTION public.set_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END; $function$
;


  create policy "goals_delete_own"
  on "public"."goals"
  as permissive
  for delete
  to public
using ((user_id = auth.uid()));



  create policy "goals_insert_own"
  on "public"."goals"
  as permissive
  for insert
  to public
with check ((user_id = auth.uid()));



  create policy "goals_select_own"
  on "public"."goals"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "goals_update_own"
  on "public"."goals"
  as permissive
  for update
  to public
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "profiles_insert_self"
  on "public"."profiles"
  as permissive
  for insert
  to public
with check ((id = auth.uid()));



  create policy "profiles_select_own"
  on "public"."profiles"
  as permissive
  for select
  to public
using ((id = auth.uid()));



  create policy "profiles_update_own"
  on "public"."profiles"
  as permissive
  for update
  to public
using ((id = auth.uid()));



  create policy "schedules_delete_own"
  on "public"."schedules"
  as permissive
  for delete
  to public
using ((user_id = auth.uid()));



  create policy "schedules_insert_own"
  on "public"."schedules"
  as permissive
  for insert
  to public
with check ((user_id = auth.uid()));



  create policy "schedules_select_own"
  on "public"."schedules"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "schedules_update_own"
  on "public"."schedules"
  as permissive
  for update
  to public
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "user_settings_delete_own"
  on "public"."user_settings"
  as permissive
  for delete
  to public
using ((user_id = auth.uid()));



  create policy "user_settings_insert_own"
  on "public"."user_settings"
  as permissive
  for insert
  to public
with check ((user_id = auth.uid()));



  create policy "user_settings_select_own"
  on "public"."user_settings"
  as permissive
  for select
  to public
using ((user_id = auth.uid()));



  create policy "user_settings_update_own"
  on "public"."user_settings"
  as permissive
  for update
  to public
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));


CREATE TRIGGER trg_goals_updated_at BEFORE UPDATE ON public.goals FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER trg_goals_user_immutable BEFORE UPDATE ON public.goals FOR EACH ROW EXECUTE FUNCTION prevent_user_id_change();

CREATE TRIGGER on_new_profile_created AFTER INSERT ON public.profiles FOR EACH ROW EXECUTE FUNCTION handle_new_user_settings();

CREATE TRIGGER trg_profiles_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER trg_schedules_updated_at BEFORE UPDATE ON public.schedules FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER trg_schedules_user_immutable BEFORE UPDATE ON public.schedules FOR EACH ROW EXECUTE FUNCTION prevent_user_id_change();

CREATE TRIGGER trg_user_settings_updated_at BEFORE UPDATE ON public.user_settings FOR EACH ROW EXECUTE FUNCTION set_updated_at();


